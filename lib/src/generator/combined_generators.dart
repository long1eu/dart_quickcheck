// File created by
// Lung Razvan <long1eu>
// on 19/09/2018

import 'dart:math';

import 'package:dart_quickcheck/src/extendible_generator.dart';
import 'package:dart_quickcheck/src/frequency_generator.dart';
import 'package:dart_quickcheck/src/generator.dart';
import 'package:dart_quickcheck/src/generator/primitive_generators.dart';
import 'package:dart_quickcheck/src/generator/support/default_frequency_generator.dart';
import 'package:dart_quickcheck/src/generator/support/ensured_values_generator.dart';
import 'package:dart_quickcheck/src/generator/support/integer_generator.dart';
import 'package:dart_quickcheck/src/generator/support/iterator_generator.dart';
import 'package:dart_quickcheck/src/generator/support/list_generator.dart';
import 'package:dart_quickcheck/src/generator/support/map_generator.dart';
import 'package:dart_quickcheck/src/generator/support/set_generator.dart';
import 'package:dart_quickcheck/src/generator/support/sorted_list_generator.dart';
import 'package:dart_quickcheck/src/generator/support/submap_generator.dart';
import 'package:dart_quickcheck/src/generator/support/subset_generator.dart';
import 'package:dart_quickcheck/src/generator/support/unique_comparable_values_generator.dart';
import 'package:dart_quickcheck/src/generator/support/unique_values_generator.dart';
import 'package:dart_quickcheck/src/generator/support/vetoable_generator.dart';
import 'package:dart_quickcheck/src/statefull_generator.dart';

/**
 * {@link CombinedGenerators} can be used to create custom {@link Generator}s.
 */
class CombinedGenerators {
  static const int DEFAULT_COLLECTION_MAX_SIZE = ListGenerator.MAX_SIZE;

  // TODO this could be a bit high
  // for runs = 200 this means 20000 tries for the worst case
  static const int DEFAULT_MAX_TRIES = VetoableGenerator.DEFAULT_MAX_TRIES;

  /**
   * <p>
   * Create a frequency generator. The frequency of {@link Generator} usage
   * depends on the generator weight.
   * </p>
   *
   * @param generator
   *            pairs of generators and their weights used to created the
   *            values
   * @param <T>
   *            type of values generated by the generators.
   */
  static FrequencyGenerator<T> frequency<T>(
      Generator<T> generator, int weight) {
    return new DefaultFrequencyGenerator<T>(generator, weight);
  }

  /**
   * OneOf is a convenience method for
   * {@link CombinedGenerators#frequency(Generator, int)} when all generator
   * share the same weight.
   */
  static ExtendibleGenerator<T, T> oneOf<T>(Generator<T> generator) {
    return frequency(generator, 1);
  }

  /**
   * Create a generator of sets with values from the content generator.
   *
   * @param <T>
   *            type of set elements generated
   * @param content
   *            generator providing the content of sets generated
   */
  static Generator<Set<T>> setsFromContent<T>(Generator<T> content) {
    return new SetGenerator<T>.fromContent(content);
  }

  /**
   * Create a generator of sets with values from the content generator.
   *
   * @param <T>
   *            type of set elements generated
   * @param content
   *            generator providing the content of sets generated
   * @param size
   *            size of the sets generated
   */
  static Generator<Set<T>> sets<T>(Generator<T> content, Generator<int> size) {
    return new SetGenerator<T>(content, size, DEFAULT_MAX_TRIES);
  }

  /**
   * Create a generator of sets with values from the content generator. Length
   * is between high and low.
   *
   * @param <T>
   *            type of set elements generated
   * @param content
   *            generator providing the content of sets generated
   * @param low
   *            minimal size
   * @param high
   *            max size
   */
  static Generator<Set<T>> setsWithSize<T>(
      Generator<T> content, int low, int high) {
    return new SetGenerator<T>(content,
        PrimitiveGenerators.integersFromRange(low, high), DEFAULT_MAX_TRIES);
  }

  /**
   * Create a generator of sets that are not empty.
   *
   * @param <T>
   *            type of set elements generated
   * @param content
   *            generator providing the content of sets generated
   */
  static Generator<Set<T>> nonEmptySets<T>(Generator<T> content) {
    return setsWithSize(content, 1, SetGenerator.MAX_SIZE);
  }

  /**
   * Create a generator of subsets from a given set.
   *
   * @param <T>
   *            type of set elements generated
   * @param superset
   *            of the generated set
   */
  static Generator<Set<T>> setsWithSuperset<T>(Set<T> superset) {
    return new SubsetGenerator<T>(superset);
  }

  /**
   * Create a generator of subsets from a given set.
   *
   * @param <T>
   *            type of set elements generated
   * @param superset
   *            of the generated set
   * @param size
   *            of the generated set
   */
  static Generator<Set<T>> setsWithSupersetAndSize<T>(
      Set<T> superset, Generator<int> size) {
    return new SubsetGenerator<T>(superset, size);
  }

  /**
   * Create a generator of iterators.
   *
   * <p>
   * Values of the elements will be taken from the content generator.
   * </p>
   *
   * @param <T>
   *            type of iterator elements generated
   * @param content
   *            generator providing the content of iterators generated
   */
  static Generator<Iterator<T>> iteratorsWithContent<T>(Generator<T> content) {
    return new IteratorGenerator<T>.withContent(content);
  }

  /**
   * Create a generator of iterators.
   *
   * <p>
   * Values of the elements will be taken from the content generator. The
   * generated iterator will have at least one element.
   * </p>
   *
   * @param <T>
   *            type of iterator elements generated
   * @param content
   *            generator providing the content of iterators generated
   */
  static Generator<Iterator<T>> nonEmptyIterators<T>(Generator<T> content) {
    return new IteratorGenerator<T>.withContentAndRange(
        content, 1, IteratorGenerator.MAX_SIZE);
  }

  /**
   * Create a generator of iterators.
   *
   * <p>
   * Values of the elements will be taken from the content generator. The
   * length of the iterators will be determined with the size generator.
   * </p>
   *
   * @param <T>
   *            type of iterator elements generated
   * @param content
   *            generator providing the content of iterators generated
   * @param size
   *            used to determine the number of elements of the iterator
   */
  static Generator<Iterator<T>> iterators<T>(
      Generator<T> content, Generator<int> size) {
    return IteratorGenerator<T>(content, size);
  }

  /**
   * Create a generator of lists with values from the content generator.
   * Length values of lists generated will be created with
   * {@link Distribution#UNIFORM}.
   *
   * @param <T>
   *            type of list elements generated
   * @param content
   *            generator providing the content of lists generated
   */
  static Generator<List<T>> listsWithContent<T>(Generator<T> content) {
    return new ListGenerator<T>.withContent(content);
  }

  /**
   * Create a generator of non-empty lists with values from the content
   * generator. Length values of lists generated will be created with
   * {@link Distribution#UNIFORM}.
   *
   * @param <T>
   *            type of list elements generated
   * @param content
   *            generator providing the content of lists generated
   */
  static Generator<List<T>> nonEmptyLists<T>(Generator<T> content) {
    return listsWithContentAndSize(content,
        PrimitiveGenerators.positiveIntegersUntil(IntegerGenerator.MAX_VALUE));
  }

  /**
   * Create a generator of lists with values from the content generator.
   * Length values of lists generated will be created with size generator.
   *
   * @param <T>
   *            type of list elements generated
   * @param content
   *            generator providing the content of lists generated
   * @param size
   *            integer used to determine the list size
   */
  static Generator<List<T>> listsWithContentAndSize<T>(
      Generator<T> content, Generator<int> size) {
    return new ListGenerator<T>.fromValues(content, size);
  }

  /**
   * Create a generator of lists with values from the content generator.
   * Length is between high and low.
   *
   * @param <T>
   *            type of list elements generated
   * @param content
   *            generator providing the content of lists generated
   * @param low
   *            minimal size
   * @param high
   *            max size
   */
  static Generator<List<T>> lists<T>(Generator<T> content, int low, int high) {
    return listsWithContentAndSize(content, new IntegerGenerator(low, high));
  }

  /**
   * Create a generator of lists with values from the content generator.
   * Length is at least low.
   *
   * @param <T>
   *            type of list elements generated
   * @param content
   *            generator providing the content of lists generated
   * @param low
   *            minimal size. If low is larger than
   *            {@link CombinedGenerators#DEFAULT_COLLECTION_MAX_SIZE} then it
   *            is the upper size bound as well.
   */
  static Generator<List<T>> listsWithContentAndLow<T>(
      Generator<T> content, int low) {
    return lists(content, low, max(low, ListGenerator.MAX_SIZE));
  }

  /**
   * Create a generator of sorted lists with values from the content
   * generator.
   *
   * @param <T>
   *            type of list elements generated
   * @param content
   *            generator providing the content of lists generated
   */
  static sortedLists<T extends Comparable<T>>(Generator<T> content) {
    return new SortedListGenerator<T>(content);
  }

  /**
   * Create a generator of sorted lists with values from the content
   * generator. Length is between high and low.
   *
   * @param <T>
   *            type of list elements generated
   * @param content
   *            generator providing the content of lists generated
   * @param low
   *            minimal size
   * @param high
   *            max size
   */
  static Generator<List<T>>
      sortedListsWithContentAndRange<T extends Comparable<T>>(
          Generator<T> content, int low, int high) {
    return sortedListsWithContentAndSize(
        content, PrimitiveGenerators.integersFromRange(low, high));
  }

  /**
   * Create a generator of sorted lists with values from the content
   * generator. Length is between high and low.
   *
   * @param <T>
   *            type of list elements generated
   * @param content
   *            generator providing the content of lists generated
   * @param size
   *            integer used to determine the list size
   */
  static Generator<List<T>>
      sortedListsWithContentAndSize<T extends Comparable<T>>(
          Generator<T> content, Generator<int> size) {
    return new SortedListGenerator<T>(content, size);
  }

  /**
   * Create a generator of {@link Map maps}.
   *
   * <p>This is a generator for simple maps where the values are not related to the keys.</p>
   *
   * @param keys
   *            {@link Generator} for the keys of the map
   * @param values
   *            {@link Generator} for the values of the map
   */
  static Generator<Map<K, V>> maps<K, V>(
      Generator<K> keys, Generator<V> values) {
    return new MapGenerator<K, V>(keys, values);
  }

  /**
   * Create a generator of {@link Map maps}.
   *
   * <p>This is a generator for simple maps where the values are not related to the keys.</p>
   *
   * @param keys
   *            {@link Generator} for the keys of the map
   * @param values
   *            {@link Generator} for the values of the map
   * @param size
   *            integer used to determine the size of the generated map
   */
  static Generator<Map<K, V>> mapsFromKeysAndValuesOfSize<K, V>(
      Generator<K> keys, Generator<V> values, Generator<int> size) {
    return new MapGenerator<K, V>(keys, values, size);
  }

  /**
   * Create a generator of maps from a given map.
   *
   * <p>The entry set of the generated maps are subsets of the given map's entry set.</p>
   * @param supermap
   *            of the generated maps
   */
  static Generator<Map<K, V>> mapsFromSupermap<K, V>(Map<K, V> supermap) {
    return new SubmapGenerator<K, V>(supermap);
  }

  /**
   * Create a generator of maps from a given map.
   *
   * <p>The entry set of the generated maps are subsets of the given map's entry set.</p>
   *
   * @param supermap
   *            of the generated maps
   * @param sizes
   *            of the generated maps
   */
  static Generator<Map<K, V>> mapsFromValues<K, V>(
      Map<K, V> supermap, Generator<int> sizes) {
    return new SubmapGenerator<K, V>(supermap, sizes);
  }

  /**
   * Create a deterministic generator which guarantees that all values from
   * the ensuredValues collection will be returned if enough calls to
   * {@link Generator#next()} are issued (i.e. ensuredValues.size() <= # of
   * runs). The order of values is undefined.
   *
   * @param <T>
   *            type of values return by the generator
   */
  static StatefulGenerator<T> ensureValues<T>(List<T> ensuredValues) {
    return new EnsuredValuesGenerator<T>(ensuredValues);
  }

  /**
   * Create a deterministic generator which guarantees that all values from
   * the ensuredValues array will be returned if enough calls to
   * {@link Generator#next()} are issued (i.e. ensuredValues.size() <= # of
   * runs). The order of values is undefined.
   *
   * @param <T>
   *            type of values return by the generator
   */
  static StatefulGenerator<T> ensureValuesWithContent<T>(List<T> content) {
    return ensureValues(content);
  }

  /**
   * <p>
   * Create a deterministic generator which guarantees that all values from
   * the ensuredValues collection will be returned if enough calls to
   * {@link Generator#next()} are issued (i.e. ensuredValues.size() <= # of
   * runs). The order of values is undefined.
   * </p>
   * <p>
   * If all values of ensuredValues are generated calls to
   * {@link Generator#next()} will return values from the otherValues
   * generator.
   * </p>
   *
   * @param <T>
   *            type of values return by the generator
   */
  static StatefulGenerator<T> ensureValuesFromValues<T>(
      List<T> ensuredValues, Generator<T> otherValues) {
    return new EnsuredValuesGenerator<T>(ensuredValues, otherValues);
  }

  /**
   * <p>
   * Create a generator that ensures unique values.
   * </p>
   * <p>
   * The actual values are created with an arbitrary generator.
   * </p>
   * <p>
   * Note: unique generator depends on valid implementation of equals and
   * hashCode method of the content type generated.
   * </p>
   *
   * @param <T>
   *            type of values return by the generator
   * @param generator
   *            used to create the raw values. This generator can
   *            create duplicate values
   * @param tries
   *            Number of tries to create a new unique value. After this
   *            number of tries is exceeded the generation aborts with a
   *            {@link GeneratorException}.
   * @return unique generator instance
   */
  static StatefulGenerator<T> uniqueValues<T>(
      Generator<T> generator, int tries) {
    return new UniqueValuesGenerator<T>(generator, tries);
  }

  /**
   * <p>
   * Create a generator that ensures unique values.
   * </p>
   * <p>
   * The actual values are created with an arbitrary generator.
   * </p>
   * <p>
   * Unique generator depends on the {@link Comparator} implementation to
   * decide if two instances are the same (i.e. when the comparator returns 0
   * for {@link Comparator#compare(Object, Object)}).
   * </p>
   *
   * @param <T>
   *            type of values returned by the generator
   * @param generator
   *            used to create the raw values. This generator can create
   *            duplicate values
   * @param comparator
   *            that decides if two values are of the same equivalence class.
   * @param tries
   *            Number of tries to create a new unique value. After this
   *            number of tries is exceeded the generation aborts with a
   *            {@link GeneratorException}.
   * @return unique generator instance
   */
  static StatefulGenerator<T> uniqueValuesWithRetries<T>(
      Generator<T> generator, Comparator<T> comparator, int tries) {
    return new UniqueComparableValuesGenerator<T>(generator, comparator, tries);
  }

  /**
   * <p>
   * Create a generator that ensures unique values.
   * </p>
   * <p>
   * The actual values are created with an arbitrary generator.
   * </p>
   * <p>
   * Unique generator depends on the {@link Comparator} implementation to
   * decide if two instances are the same (i.e. when the comparator returns 0
   * for {@link Comparator#compare(Object, Object)}).
   * </p>
   *
   * @param <T>
   *            type of values returned by the generator
   * @param generator
   *            used to create the raw values. This generator can create
   *            duplicate values
   * @param comparator
   *            that decides if two values are of the same equivalence class.
   * @return unique generator instance
   */
  static StatefulGenerator<T> uniqueValuesFor<T>(
      Generator<T> generator, Comparator<T> comparator) {
    return uniqueValuesWithRetries(generator, comparator, DEFAULT_MAX_TRIES);
  }

  /**
   * <p>
   * Create a generator that ensures unique values
   * </p>
   * <p>
   *  The actual values are created with an arbitrary generator.
   * </p>
   * <p>
   * Note: unique generator depends on valid implementation of equals and
   * hashCode method of the content type generated.
   * </p>
   *
   * @param <T>
   *            type of values return by the generator
   * @param generator
   *            used to create the raw values. This generator can
   *            create duplicate values
   * @return unique generator instance
   */
  static StatefulGenerator<T> uniqueValuesForContent<T>(
      Generator<T> generator) {
    return new UniqueValuesGenerator<T>(generator, DEFAULT_MAX_TRIES);
  }
}
